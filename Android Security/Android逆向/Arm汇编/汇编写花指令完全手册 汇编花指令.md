# 汇编写花指令完全手册 汇编花指令

src:https://lcx.cc/post/786/



使用汇编语言(Asm)编写花指令完全手册，汇编语言(Asm)中的花指令详解。

# 一、花指令概念

花指令是一堆汇编指令组成，对于程序来说，是一堆废话，加不加花指令都不影响程序的正常运行。

简单地说，例如计算：1+1=2，这个很简单的算式。如果加入花指令的话，则是变成了这样的：

“1+1+2-2+4+5+6-4-5-6-7-8-9+7+8+9+0=2”

后边的“+2-2+4+5+6-4-5-6-7-8-9+7+8+9+0”全是废话，全部互相抵消了，跟没有没什么区别，这就是花指令。

要注意的是，编写的花指令要终始保持堆栈的平衡。

保持堆栈平衡，可以简单的理解为：就是让后边的那一大堆废话“+2-2+4+5+6-4-5-6-7-8-9+7+8+9+0”，全部互相抵消，始终保持为“0”。不论存不存在，都不影响原算式的结果、值，这个就是保持堆栈平衡。说白了，就是保持原始计算结果不变。


# 二、编写花指令的原则

   编写花指令的基本原则，就是要保持堆栈的平衡（废话，堆栈不平衡，运行结果就变了，程序就会出错，这就不叫花指令了）。

   编写花指令，细细品味下面一段比喻：

   我们把一段花指令比喻成一道数学运算题，把汇编指令(push pop 之类的)比喻成加减乘除，把寄存器或数据(eax, ebx, 1 等)比喻成数字(1, 2, 3 等)。那么要保持花指令堆栈的平衡，等于保持这道数学题的结果始终是0。

# 三、解释一些指令含意
```c
   A.以下指令均为两条一组，两条指令之间互相抵消，nop 指令自己跟自己抵消，相当于“0”。
  -----------------------------------------
   nop         //不执行，空操作。（详见底下的“Nop 指令说明”）
   -----------------------------------------
   push ebp    //把基址指针寄存器压入堆栈
   pop ebp     //把基址指针寄存器弹出堆栈
   -----------------------------------------
   push eax    //把数据寄存器压入堆栈
   pop eax     //把数据寄存器弹出堆栈
   -----------------------------------------
   push esp    //把指针寄存器压入堆栈
   pop esp     //把指针寄存器弹出堆栈
   -----------------------------------------
   add esp,1    //指针寄存器加1
   sub esp,1   //指针寄存器减1
   -----------------------------------------
   inc ecx     //计数器加1
   dec ecx     //计数器减1
   -----------------------------------------
   sub esp,1   //指针寄存器加1
   sub esp,-1  //指针寄存器减1
   -----------------------------------------

   B、跳到程序入口地址、指定地址指令。
   -----------------------------------------
   jmp  入口地址      //跳到程序入口地址。
   -----------------------------------------
   push 入口地址      //把入口地址压入堆栈。
   retn               //返回到入口地址，整体效果与(jmp 入口地址)一样。
   -----------------------------------------
   jb   入口地址      //效果和jmp入口地址一样，直接跳到程序入口地址。
   jnb  入口地址      //效果和jmp入口地址一样，直接跳到程序入口地址。
   -----------------------------------------
   mov eax, 入口地址  //把入口地址传送到数据寄存器中。
   jmp eax            //跳到数据寄存器中的地址，也就是程序入口地址。
   -----------------------------------------
```

# 四、免杀花指令编写手册

   注意：以下指令均为两个一组互相抵消，详细请参考上边的“指令含意”。以后编写花指令，都可以参考本手册，灵活组合，快速写出自己的花指令。

```c
   -----------------------------------------
   push ebp            //把基址指针寄存器压入堆栈
   pop ebp             //把基址指针寄存器弹出堆栈
   -----------------------------------------
   push eax            //把数据寄存器压入堆栈
   pop eax             //把数据寄存器弹出堆栈
   -----------------------------------------
   push esp            //把指针寄存器压入堆栈
   pop esp             //把指针寄存器弹出堆栈
   -----------------------------------------
   push 0              //相当于0，自身与自身抵消
   -----------------------------------------
   push 10             //其中数字可以任意，注意与下面对应。相当于加上10
   push -10            //相当于减去10，+10-10=0
   -----------------------------------------
   nop                 //可任意在中间添加，不执行，空操作，自身与自身抵消
   -----------------------------------------
   move edi, edi       //效果与nop一样，自身与自身抵消
   -----------------------------------------
   add esp, 1          //其中数字可以任意，注意以下面对应。相当于加上1
   add esp, -1         //相当于减去1，+1-1=0
   -----------------------------------------
   add esp, 1          //其中数字可以任意，注意以下面对应。相当于加上1
   sub esp, 1          //相当于减去1，+1-1=0
   -----------------------------------------
   inc ecx             //计数器加1
   dec ecx             //计数器加1
   -----------------------------------------
   sub eax, -2         //指针寄存器减2。其中数字可任意，与inc的个数对应
   inc eax             //指针寄存器加1
   inc eax             //指针寄存器加1
   -----------------------------------------
   sub esp,1           //指针寄存器加1
   sub esp,-1          //指针寄存器减1
   -----------------------------------------
   add eax -2          //数据寄存器减2。其中数字可任意，与inc的个数对应
   inc eax             //数据寄存器加1
   inc eax             //数据寄存器加1
   -----------------------------------------
   jmp 底下的jmp地址   //跳到底下的jmp地址继续执行，意思就是跳过本行，继续执行
   jmp 底下的指令地址  //跳到底下指令地址继续执行，意思就是跳过本行，继续执行底下的指令
   -----------------------------------------
   push ebp            //把基址指针寄存器压入堆栈
   mov ebp, esp        //移动基址指针寄存器到指针寄存器
   -----------------------------------------
   jmp 入口地址        //最后跳到程序原入口地址，继续执行原程序。
   -----------------------------------------
```

# 扩展知识

Nop 指令说明：CPU 不执行此指令，但占用一个指令周期(也就是 CPU 空闲一会儿，详见底下的“什么是指令周期”)，指令周期(空闲时间)的长短因 CPU 不同等因素而不同。

   什么是指令周期？

   指令周期是执行一条指令所需要的时间，一般由若干个机器周期组成，是从取指令、分析指令到执行完所需的全部时间。

   CPU 从内存取出一条指令并执行这条指令的时间总和。

   指令不同，所需的机器周期数也不同。对于一些简单的的单字节指令，在取指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要两个或者两个以上的机器周期。

   从指令的执行速度看，单字节和双字节指令一般为单机器周期和双机器周期，三字节指令都是双机器周期，只有乘、除指令占用4个机器周期。在编程时要注意选用具有同样功能而机器周期数少的指令。