/**
 * AesArrays.h
 * @Author  Tu Yongce <tuyongce (at) 163 (dot) com>
 * @Date    Aug. 4 2007 
 * @Last    Aug. 20 2007  
 * @version 0.2
 */

#ifndef __AES_ARRAYS_H__
#define __AES_ARRAYS_H__

#include <iomanip>

typedef unsigned __int32 u32_t;

/**
 * Dump an array with type T into output stream in hex form.
 * @param os: Output stream.
 * @param name: Array name.
 * @param num: Size of the array.
 * @param width: Number of elements on each output line.
 */
template<typename T>
void dumpData(std::ostream &os, const char *name, T arr[], size_t num, size_t width)
{
    os << (sizeof(T) == 4 ? "u32_t " : (sizeof(T) == 1 ? "unsigned char " : "T "));
    os << name << '[' << num << "] = {" << endl << "    ";

    char oldFill = os.fill('0');
    ios_base::fmtflags state = os.flags(ios::hex);

    for (size_t i = 0; i <num; ) {
        os << "0x" << std::setw(2 * sizeof(T)) << static_cast<unsigned int>(arr[i++]) << ", ";
        if (i % width == 0) {
            os << std::endl;
            if (i < num)
                os << "    ";
        }
    }
    if (num % width != 0)
        os << '\n';
    os << "};" << std::endl;

    os.fill(oldFill);
    os.flags(state);
}

/**
 * Generate RC values for RoundConstant.
 * @param rc[]: Hold the RC values generated.
 * @param num: Number of RC values to be generated.
 */
void generateRC(unsigned char rc[], size_t num);

/**
 * Multiply two numbers under polynomial GF(2^8).
 * @return: The product of @param a and @param b.
 */
unsigned char mul(unsigned char a, unsigned char b);

/**
 * Calculate multiplicative inverse under polynomial GF(2^8).
 * @return: Multiplicative inverse of @param a.
 */
unsigned char getMulInverse(unsigned char a);

/**
 * Calculate multiplicative inverse table under polynomial GF(2^8).
 * @param mulIv: Array which holds the multiplicative inverse table.
 * @param num: Size of the array.
 */
void getMulInvTable(unsigned char mulInv[], size_t num);

/**
 * Calculate S-Box (Substitute Bytes) and inverse S-Box (Inverse Substitute Bytes) under polynomial GF(2^8).
 * @param sbox: Array which holds the sbox table.
 * @param isbox: Array which holds the inverse sbox table.
 * @param num: Size of the array (should be 256).
 */
void getSbox(unsigned char sbox[], unsigned char isbox[], size_t num);

/**
 * MixColumns transformation.
 * @param w: Machine word (int32) to be transformed.
 * @return: Machine word generated by MixColumns transformation.
 */
u32_t mixColumn(u32_t w);

/**
 * Get MixColumns transformation array.
 * @param mc1, mc2, mc3, mc4: Arrays to hold the translation.
 * @param num: Size of the array (should be 256).
 */
void getMC(u32_t mc1[], u32_t mc2[], u32_t mc3[], u32_t mc4[], size_t num);

/**
 * Inverse MixColumns transformation.
 * @param w: Machine word (int32) to be transformed.
 * @return: Machine word generated by inverse MixColumns transformation.
 */
u32_t invMixColumn(u32_t w);

/**
 * Get inverse MixColumns transformation array.
 * @param imc1, imc2, imc3, imc4: Arrays to hold the translation.
 * @param num: Size of the array (should be 256).
 */
void getIMC(u32_t imc1[], u32_t imc2[], u32_t imc3[], u32_t imc4[], size_t num);

/**
 * Get transformation table including SubstituteBytes and MixColumns for encryption.
 * @param te1, te2, te3, te4: Arrays to hold the translation.
 * @param sbox: S-Box for SubstituteBytes.
 * @param num: Size of the array (should be 256).
 */
void getTE(u32_t te1[], u32_t te2[], u32_t te3[], u32_t te4[], unsigned char sbox[], size_t num);

/**
 * Get transformation table including inverse SubstituteBytes and inverse MixColumns for decryption.
 * @param td1, td2, td3, td4: Arrays to hold the translation.
 * @param isbox: Inverse S-Box for inverse SubstituteBytes.
 * @param num: Size of the array (should be 256).
 */
void getTD(u32_t td1[], u32_t td2[], u32_t td3[], u32_t td4[], unsigned char isbox[], size_t num);

#endif // __AES_ARRAYS_H__
