/**
 * AesArrays.cpp
 * @Author  Tu Yongce <tuyongce (at) 163 (dot) com>
 * @Date    Aug. 4 2007 
 * @Last    Aug. 20 2007  
 * @version 0.2
 */

#include "AesArrays.h"

using namespace std;

/**
 * Generate RC values for RoundConstant.
 * @param rc[]: Hold the RC values generated.
 * @param num: Number of RC values to be generated.
 */
void generateRC(unsigned char rc[], size_t num)
{	
	rc[0] = 0x01;
	for (size_t i = 1; i < num; ++i) {
        // RC[i] = 2 * RC[i - 1] ==> x * f(x)
		if (rc[i - 1] & 0x80)
			rc[i] = (rc[i - 1] << 1) ^ 0x1B;
		else
			rc[i] = rc[i - 1] << 1;
	}
}

/**
 * Multiply two numbers under polynomial GF(2^8).
 * @return: The product of @param a and @param b.
 */
unsigned char mul(unsigned char a, unsigned char b)
{
    unsigned char ret = 0;

    for (int i = 0; i < 8; ++i) {
        if (b & 0x01)
            ret ^= a;
        if (a & 0x80) {
            a <<= 1;
            a ^= 0x1B;
        } else
            a <<= 1;
        b >>= 1;
    }

	return ret;
}

/**
 * Calculate multiplicative inverse under polynomial GF(2^8).
 * @return: Multiplicative inverse of @param a.
 */
unsigned char getMulInverse(unsigned char a)
{
    unsigned char ret = 1;
    while (mul(a, ret) != 1)
        ++ret;

    return ret;
}

/**
 * Calculate multiplicative inverse table under polynomial GF(2^8).
 * @param mulIv: Array which holds the multiplicative inverse table.
 * @param num: Size of the array.
 */
void getMulInvTable(unsigned char mulInv[], size_t num)
{
    mulInv[0] = 0;
    for (size_t i = 1; i < num; ++i)
        mulInv[i] = getMulInverse(i);
}

/**
 * Calculate S-Box (Substitute Bytes) and inverse S-Box (Inverse Substitute Bytes) under polynomial GF(2^8).
 * @param sbox: Array which holds the sbox table.
 * @param isbox: Array which holds the inverse sbox table.
 * @param num: Size of the array (should be 256).
 */
void getSbox(unsigned char sbox[], unsigned char isbox[], size_t num)
{
    sbox[0] = 0x63;
    isbox[0x63] = 0;
    for (size_t i = 1; i < num; ++i) {
        unsigned char tmp = getMulInverse(i);
        // b[i] = bi ^ b[(i + 4) mode 8] ^  b[(i + 5) mode 8] ^  b[(i + 6) mode 8] ^  b[(i + 7) mode 8] ^ 0x63
        tmp = tmp ^ (tmp << 4 | tmp >> 4) ^ (tmp << 3 | tmp >> 5)
                  ^ (tmp << 2 | tmp >> 6) ^ (tmp << 1 | tmp >> 7) ^ 0x63;
        if (sbox != 0)
            sbox[i] = tmp;
        if (isbox != 0)
            isbox[tmp] = i;
    }
}

/**
 * MixColumns transformation.
 * @param w: Machine word (int32) to be transformed.
 * @return: Machine word generated by MixColumns transformation.
 */
u32_t mixColumn(u32_t w)
{
    unsigned char byte0 = (w >> 24) & 0xFF;
    unsigned char byte1 = (w >> 16) & 0xFF;
    unsigned char byte2 = (w >> 8) & 0xFF;
    unsigned char byte3 = w & 0xFF;
    unsigned char b0 = mul(byte0, 2) ^ mul(byte1, 3) ^ byte2 ^ byte3;
    unsigned char b1 = byte0 ^ mul(byte1, 2) ^ mul(byte2, 3) ^ byte3;
    unsigned char b2 = byte0 ^ byte1 ^ mul(byte2, 2) ^ mul(byte3, 3);
    unsigned char b3 = mul(byte0, 3) ^ byte1 ^ byte2 ^ mul(byte3, 2);
    return (u32_t(b0) << 24) | (u32_t(b1) << 16) | (u32_t(b2) << 8) | u32_t(b3);
}

/**
 * Get MixColumns transformation array.
 * @param mc1, mc2, mc3, mc4: Arrays to hold the translation.
 * @param num: Size of the array (should be 256).
 */
void getMC(u32_t mc1[], u32_t mc2[], u32_t mc3[], u32_t mc4[], size_t num)
{
    for (size_t i = 0; i < num; ++i) {
        mc1[i] = (u32_t(mul(i, 2)) << 24) | (u32_t(i) << 16) | 
                 (u32_t(i) << 8 ) | u32_t(mul(i, 3));
        mc2[i] = (u32_t(mul(i, 3)) << 24) | (u32_t(mul(i, 2)) << 16) | 
                 (u32_t(i) << 8 ) | u32_t(i);
        mc3[i] = (u32_t(i) << 24) | (u32_t(mul(i, 3)) << 16) | 
                 (u32_t(mul(i, 2)) << 8 ) | u32_t(i);
        mc4[i] = (u32_t(i) << 24) | (u32_t(i) << 16) | 
                 (u32_t(mul(i, 3)) << 8 ) | u32_t(mul(i, 2));
    }
}

/**
 * Inverse MixColumns transformation.
 * @param w: Machine word (int32) to be transformed.
 * @return: Machine word generated by inverse MixColumns transformation.
 */
u32_t invMixColumn(u32_t w)
{
    unsigned char byte0 = (w >> 24) & 0xFF;
    unsigned char byte1 = (w >> 16) & 0xFF;
    unsigned char byte2 = (w >> 8) & 0xFF;
    unsigned char byte3 = w & 0xFF;
    unsigned char b0 = mul(byte0, 0x0E) ^ mul(byte1, 0x0B) ^ mul(byte2, 0x0D) ^ mul(byte3, 0x09);
    unsigned char b1 = mul(byte0, 0x09) ^ mul(byte1, 0x0E) ^ mul(byte2, 0x0B) ^ mul(byte3, 0x0D);
    unsigned char b2 = mul(byte0, 0x0D) ^ mul(byte1, 0x09) ^ mul(byte2, 0x0E) ^ mul(byte3, 0x0B);
    unsigned char b3 = mul(byte0, 0x0B) ^ mul(byte1, 0x0D) ^ mul(byte2, 0x09) ^ mul(byte3, 0x0E);
    return (u32_t(b0) << 24) | (u32_t(b1) << 16) | (u32_t(b2) << 8) | u32_t(b3);
}

/**
 * Get inverse MixColumns transformation table for key expansion.
 * @param imc1, imc2, imc3, imc4: Arrays to hold the translation.
 * @param num: Size of the array (should be 256).
 */
void getIMC(u32_t imc1[], u32_t imc2[], u32_t imc3[], u32_t imc4[], size_t num)
{
    for (size_t i = 0; i < num; ++i) {
        imc1[i] = (u32_t(mul(i, 0x0E)) << 24) | (u32_t(mul(i, 0x09)) << 16) | 
                  (u32_t(mul(i, 0x0D)) << 8 ) | u32_t(mul(i, 0x0B));
        imc2[i] = (u32_t(mul(i, 0x0B)) << 24) | (u32_t(mul(i, 0x0E)) << 16) | 
                  (u32_t(mul(i, 0x09)) << 8 ) | u32_t(mul(i, 0x0D));
        imc3[i] = (u32_t(mul(i, 0x0D)) << 24) | (u32_t(mul(i, 0x0B)) << 16) | 
                  (u32_t(mul(i, 0x0E)) << 8 ) | u32_t(mul(i, 0x09));
        imc4[i] = (u32_t(mul(i, 0x09)) << 24) | (u32_t(mul(i, 0x0D)) << 16) | 
                  (u32_t(mul(i, 0x0B)) << 8 ) | u32_t(mul(i, 0x0E));
    }
}

/**
 * Get transformation table including SubstituteBytes and MixColumns for encryption.
 * @param te1, te2, te3, te4: Arrays to hold the translation.
 * @param sbox: S-Box for SubstituteBytes.
 * @param num: Size of the array (should be 256).
 */
void getTE(u32_t te1[], u32_t te2[], u32_t te3[], u32_t te4[], unsigned char sbox[], size_t num)
{
    for (size_t i = 0; i < num; ++i) {
        te1[i] = (u32_t(mul(sbox[i], 2)) << 24) | (u32_t(sbox[i]) << 16) | (u32_t(sbox[i]) << 8) | u32_t(mul(sbox[i], 3));
        te2[i] = (u32_t(mul(sbox[i], 3)) << 24) | (u32_t(mul(sbox[i], 2)) << 16) | (u32_t(sbox[i]) << 8) | u32_t(sbox[i]);
        te3[i] = (u32_t(sbox[i]) << 24) | (u32_t(mul(sbox[i], 3)) << 16) | (u32_t(mul(sbox[i], 2)) << 8) | u32_t(sbox[i]);
        te4[i] = (u32_t(sbox[i]) << 24) | (u32_t(sbox[i]) << 16) | (u32_t(mul(sbox[i], 3)) << 8) | u32_t(mul(sbox[i], 2));
    }
}

/**
 * Get transformation table including inverse SubstituteBytes and inverse MixColumns for decryption.
 * @param td1, td2, td3, td4: Arrays to hold the translation.
 * @param isbox: Inverse S-Box for inverse SubstituteBytes.
 * @param num: Size of the array (should be 256).
 */
void getTD(u32_t td1[], u32_t td2[], u32_t td3[], u32_t td4[], unsigned char isbox[], size_t num)
{
    for (size_t i = 0; i < num; ++i) {
        td1[i] = (u32_t(mul(isbox[i], 0x0E)) << 24) | (u32_t(mul(isbox[i], 0x09)) << 16) | 
                 (u32_t(mul(isbox[i], 0x0D)) << 8 ) | u32_t(mul(isbox[i], 0x0B));
        td2[i] = (u32_t(mul(isbox[i], 0x0B)) << 24) | (u32_t(mul(isbox[i], 0x0E)) << 16) | 
                 (u32_t(mul(isbox[i], 0x09)) << 8 ) | u32_t(mul(isbox[i], 0x0D));
        td3[i] = (u32_t(mul(isbox[i], 0x0D)) << 24) | (u32_t(mul(isbox[i], 0x0B)) << 16) | 
                 (u32_t(mul(isbox[i], 0x0E)) << 8 ) | u32_t(mul(isbox[i], 0x09));
        td4[i] = (u32_t(mul(isbox[i], 0x09)) << 24) | (u32_t(mul(isbox[i], 0x0D)) << 16) | 
                 (u32_t(mul(isbox[i], 0x0B)) << 8 ) | u32_t(mul(isbox[i], 0x0E));
    }
}
